diff -urN package/proftpd.ORIG/proftpd-1.3.4b-008-fix_segfault.patch package/proftpd/proftpd-1.3.4b-008-fix_segfault.patch
--- package/proftpd.ORIG/proftpd-1.3.4b-008-fix_segfault.patch	1969-12-31 16:00:00.000000000 -0800
+++ package/proftpd/proftpd-1.3.4b-008-fix_segfault.patch	2013-03-01 11:56:02.725136981 -0800
@@ -0,0 +1,134 @@
+--- proftpd-1.3.4b/contrib/mod_vroot.c.ORIG	2013-02-28 23:00:03.595178893 -0800
++++ proftpd-1.3.4b/contrib/mod_vroot.c	2013-03-01 11:54:11.669157033 -0800
+@@ -53,7 +53,9 @@
+ static pool *vroot_dir_pool = NULL;
+ static pr_table_t *vroot_dirtab = NULL;
+ 
++#if PROFTPD_VERSION_NUMBER >= 0x0001030407
+ static int vroot_use_mkdtemp = FALSE;
++#endif /* ProFTPD 1.3.4c or later */
+ 
+ static unsigned int vroot_opts = 0;
+ #define	VROOT_OPT_ALLOW_SYMLINKS	0x0001
+@@ -86,7 +88,7 @@
+ }
+ 
+ static void vroot_clean_path(char *path) {
+-  char *p;
++  char *p = NULL;
+ 
+   if (path == NULL ||
+       *path == 0) {
+@@ -194,12 +196,12 @@
+ }
+ 
+ static char *vroot_realpath(pool *p, const char *path, int flags) {
+-  char *real_path;
++  char *real_path = NULL;
+   size_t real_pathlen;
+ 
+   if (flags & VROOT_REALPATH_FL_ABS_PATH) {
+     /* If not an absolute path, prepend the current location. */
+-    if (*real_path != '/') {
++    if (*path != '/') {
+       real_path = pdircat(p, pr_fs_getvwd(), path, NULL);
+ 
+     } else {
+@@ -283,7 +285,7 @@
+ 
+   } else if (*bufp != '\0') {
+     size_t buflen, tmplen;
+-    char *ptr;
++    char *ptr = NULL;
+ 
+     ptr = strstr(bufp, "..");
+     if (ptr != NULL) {
+@@ -346,7 +348,7 @@
+       start_ptr = path;
+ 
+       while (start_ptr != NULL) {
+-        char *ptr;
++        char *ptr = NULL;
+ 
+         pr_signals_handle();
+ 
+@@ -420,7 +422,7 @@
+ 
+ static int handle_vroot_alias(void) {
+   config_rec *c;
+-  pool *tmp_pool;
++  pool *tmp_pool = NULL;
+ 
+   /* Handle any VRootAlias settings. */
+ 
+@@ -509,7 +511,7 @@
+ 
+ static int vroot_stat(pr_fs_t *fs, const char *stat_path, struct stat *st) {
+   int res;
+-  char vpath[PR_TUNABLE_PATH_MAX + 1], *path;
++  char vpath[PR_TUNABLE_PATH_MAX + 1], *path = NULL;
+   pool *tmp_pool = NULL;
+ 
+   if (session.curr_phase == LOG_CMD ||
+@@ -537,7 +539,7 @@
+ 
+ static int vroot_lstat(pr_fs_t *fs, const char *orig_path, struct stat *st) {
+   int res;
+-  char vpath[PR_TUNABLE_PATH_MAX + 1], *path;
++  char vpath[PR_TUNABLE_PATH_MAX + 1], *path = NULL;
+   size_t pathlen = 0;
+   pool *tmp_pool = NULL;
+ 
+@@ -752,8 +754,8 @@
+ static int vroot_readlink(pr_fs_t *fs, const char *readlink_path, char *buf,
+     size_t max) {
+   int res;
+-  char vpath[PR_TUNABLE_PATH_MAX + 1], *path, *alias_path = NULL;
+-  pool *tmp_pool;
++  char vpath[PR_TUNABLE_PATH_MAX + 1], *path = NULL, *alias_path = NULL;
++  pool *tmp_pool = NULL;
+ 
+   if (session.curr_phase == LOG_CMD ||
+       session.curr_phase == LOG_CMD_ERR ||
+@@ -1039,8 +1041,8 @@
+ static int vroot_utimes(pr_fs_t *fs, const char *utimes_path,
+     struct timeval *tvs) {
+   int res;
+-  char vpath[PR_TUNABLE_PATH_MAX + 1], *path;
+-  pool *tmp_pool;
++  char vpath[PR_TUNABLE_PATH_MAX + 1], *path = NULL;
++  pool *tmp_pool = NULL;
+ 
+   if (session.curr_phase == LOG_CMD ||
+       session.curr_phase == LOG_CMD_ERR ||
+@@ -1085,8 +1087,8 @@
+ 
+ static int vroot_alias_dirscan(const void *key_data, size_t key_datasz,
+     void *value_data, size_t value_datasz, void *user_data) {
+-  const char *alias_path, *dir_path, *real_path;
+-  char *ptr;
++  const char *alias_path = NULL, *dir_path = NULL, *real_path = NULL;
++  char *ptr = NULL;
+ 
+   alias_path = key_data;
+   real_path = value_data;
+@@ -1142,8 +1144,8 @@
+ 
+ static void *vroot_opendir(pr_fs_t *fs, const char *orig_path) {
+   int res;
+-  char vpath[PR_TUNABLE_PATH_MAX + 1], *path;
+-  void *dirh;
++  char vpath[PR_TUNABLE_PATH_MAX + 1], *path = NULL;
++  void *dirh = NULL;
+   struct stat st;
+   size_t pathlen = 0;
+   pool *tmp_pool = NULL;
+@@ -1275,7 +1277,7 @@
+ }
+ 
+ static struct dirent *vroot_readdir(pr_fs_t *fs, void *dirh) {
+-  struct dirent *dent;
++  struct dirent *dent = NULL;
+ 
+ next_dent:
+   dent = readdir((DIR *) dirh);
