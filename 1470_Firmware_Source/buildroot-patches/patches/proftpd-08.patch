diff -urN package/proftpd.ORIG/proftpd-1.3.4b-004-fix-vrootalias.patch package/proftpd/proftpd-1.3.4b-004-fix-vrootalias.patch
--- package/proftpd.ORIG/proftpd-1.3.4b-004-fix-vrootalias.patch	1969-12-31 16:00:00.000000000 -0800
+++ package/proftpd/proftpd-1.3.4b-004-fix-vrootalias.patch	2013-02-27 10:15:14.633134324 -0800
@@ -0,0 +1,61 @@
+--- proftpd-1.3.4b/contrib/mod_vroot.c.ORIG	2013-02-22 01:15:53.688180826 -0800
++++ proftpd-1.3.4b/contrib/mod_vroot.c	2013-02-27 10:05:21.936135137 -0800
+@@ -699,10 +699,11 @@
+   return res;
+ }
+ 
+-static int vroot_readlink(pr_fs_t *fs, const char *path, char *buf,
++static int vroot_readlink(pr_fs_t *fs, const char *readlink_path, char *buf,
+     size_t max) {
+   int res;
+-  char vpath[PR_TUNABLE_PATH_MAX + 1];
++  char vpath[PR_TUNABLE_PATH_MAX + 1], *path, *alias_path = NULL;
++  pool *tmp_pool;
+ 
+   if (session.curr_phase == LOG_CMD ||
+       session.curr_phase == LOG_CMD_ERR ||
+@@ -711,13 +712,33 @@
+     /* NOTE: once stackable FS modules are supported, have this fall through
+      * to the next module in the stack.
+      */
+-    return readlink(path, buf, max);
++    return readlink(readlink_path, buf, max);
+   }
+ 
+-  if (vroot_lookup_path(NULL, vpath, sizeof(vpath)-1, path, 0, NULL) < 0)
++  /* In order to find any VRootAlias paths, we need to use the full path.
++   * However, if we do NOT find any VRootAlias, then we do NOT want to use
++   * the full path.
++   */
++
++  tmp_pool = make_sub_pool(session.pool);
++  path = vroot_realpath(tmp_pool, readlink_path, VROOT_REALPATH_FL_ABS_PATH);
++
++  if (vroot_lookup_path(tmp_pool, vpath, sizeof(vpath)-1, path, 0,
++      &alias_path) < 0) {
++    destroy_pool(tmp_pool);
+     return -1;
++  }
++
++  if (alias_path == NULL) {
++    if (vroot_lookup_path(NULL, vpath, sizeof(vpath)-1, readlink_path, 0,
++        NULL) < 0) {
++      destroy_pool(tmp_pool);
++      return -1;
++    }
++  }
+ 
+   res = readlink(vpath, buf, max);
++  destroy_pool(tmp_pool);
+   return res;
+ }
+ 
+@@ -1162,7 +1183,7 @@
+        */
+ 
+       for (i = 0; i < vroot_dir_aliases->nelts; i++) {
+-        if (strcmp(dent->d_name, elts[i]) == 0) {
++        if (strncmp(dent->d_name, elts[i], dent->d_namlen + 1) == 0) {
+           (void) pr_log_writefile(vroot_logfd, MOD_VROOT_VERSION,
+             "skipping directory entry '%s', as it is aliased", dent->d_name);
+           goto next_dent;
diff -urN package/proftpd.ORIG/proftpd-1.3.4b-005-upgrade_to_bleeding_edge.patch package/proftpd/proftpd-1.3.4b-005-upgrade_to_bleeding_edge.patch
--- package/proftpd.ORIG/proftpd-1.3.4b-005-upgrade_to_bleeding_edge.patch	1969-12-31 16:00:00.000000000 -0800
+++ package/proftpd/proftpd-1.3.4b-005-upgrade_to_bleeding_edge.patch	2013-02-27 10:19:01.222142797 -0800
@@ -0,0 +1,609 @@
+--- proftpd-1.3.4b/contrib/mod_vroot.c.ORIG	2013-02-27 10:05:21.936135137 -0800
++++ proftpd-1.3.4b/contrib/mod_vroot.c	2013-02-27 09:56:49.089150784 -0800
+@@ -2,7 +2,7 @@
+  * ProFTPD: mod_vroot -- a module implementing a virtual chroot capability
+  *                       via the FSIO API
+  *
+- * Copyright (c) 2002-2011 TJ Saunders
++ * Copyright (c) 2002-2013 TJ Saunders
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+@@ -32,11 +32,11 @@
+ #include "conf.h"
+ #include "privs.h"
+ 
+-#define MOD_VROOT_VERSION 	"mod_vroot/0.9.2"
++#define MOD_VROOT_VERSION 	"mod_vroot/0.9.3"
+ 
+ /* Make sure the version of proftpd is as necessary. */
+-#if PROFTPD_VERSION_NUMBER < 0x0001030201
+-# error "ProFTPD 1.3.2rc1 or later required"
++#if PROFTPD_VERSION_NUMBER < 0x0001030407
++# error "ProFTPD 1.3.4c or later required"
+ #endif
+ 
+ static const char *vroot_log = NULL;
+@@ -53,9 +53,14 @@
+ static pool *vroot_dir_pool = NULL;
+ static pr_table_t *vroot_dirtab = NULL;
+ 
++static int vroot_use_mkdtemp = FALSE;
++
+ static unsigned int vroot_opts = 0;
+ #define	VROOT_OPT_ALLOW_SYMLINKS	0x0001
+ 
++/* vroot_realpath() flags */
++#define VROOT_REALPATH_FL_ABS_PATH	0x001
++
+ /* vroot_lookup_path() flags */
+ #define VROOT_LOOKUP_FL_NO_ALIASES	0x0001
+ 
+@@ -68,8 +73,10 @@
+  */
+ 
+ static void strmove(register char *dst, register const char *src) {
+-  if (!dst || !src)
++  if (dst == NULL ||
++      src == NULL) {
+     return;
++  }
+ 
+   while (*src != 0) {
+     *dst++ = *src++;
+@@ -81,23 +88,29 @@
+ static void vroot_clean_path(char *path) {
+   char *p;
+ 
+-  if (path == NULL || *path == 0)
++  if (path == NULL ||
++      *path == 0) {
+       return;
++  }
+ 
+-  while ((p = strstr(path, "//")) != NULL)
++  while ((p = strstr(path, "//")) != NULL) {
+     strmove(p, p + 1);
++  }
+ 
+-  while ((p = strstr(path, "/./")) != NULL)
++  while ((p = strstr(path, "/./")) != NULL) {
+     strmove(p, p + 2);
++  }
+ 
+-  while (strncmp(path, "../", 3) == 0)
++  while (strncmp(path, "../", 3) == 0) {
+     path += 3;
++  }
+ 
+   p = strstr(path, "/../");
+   if (p != NULL) {
+     if (p == path) {
+-      while (strncmp(path, "/../", 4) == 0)
++      while (strncmp(path, "/../", 4) == 0) {
+         strmove(path, path + 3);
++      }
+ 
+       p = strstr(path, "/../");
+     }
+@@ -105,14 +118,19 @@
+     while (p != NULL) {
+       char *next_elem = p + 4;
+ 
+-      if (p != path && *p == '/') 
++      if (p != path &&
++          *p == '/') {
+         p--;
++      }
+ 
+-      while (p != path && *p != '/')
++      while (p != path &&
++             *p != '/') {
+         p--;
++      }
+ 
+-      if (*p == '/')
++      if (*p == '/') {
+         p++;
++      }
+ 
+       strmove(p, next_elem);
+       p = strstr(path, "/../");
+@@ -124,36 +142,45 @@
+   if (*p == '.') {
+     p++;
+ 
+-    if (*p == '\0')
++    if (*p == '\0') {
+       return;
++    }
+ 
+     if (*p == '/') {
+-      while (*p == '/') 
++      while (*p == '/') {
+         p++;
++      }
+ 
+       strmove(path, p);
+     }
+   }
+ 
+-  if (*p == '\0')
++  if (*p == '\0') {
+     return;
++  }
+ 
+   p = path + strlen(path) - 1;
+-  if (*p != '.' || p == path)
++  if (*p != '.' ||
++      p == path) {
+     return;
++  }
+ 
+   p--;
+-  if (*p == '/' || p == path) {
++  if (*p == '/' ||
++      p == path) {
+     p[1] = '\0';
+     return;
+   }
+ 
+-  if (*p != '.' || p == path)
++  if (*p != '.' ||
++      p == path) {
+     return;
++  }
+ 
+   p--;
+-  if (*p != '/')
++  if (*p != '/') {
+     return;
++  }
+ 
+   *p = '\0';
+   p = strrchr(path, '/');
+@@ -166,6 +193,38 @@
+   p[1] = '\0';
+ }
+ 
++static char *vroot_realpath(pool *p, const char *path, int flags) {
++  char *real_path;
++  size_t real_pathlen;
++
++  if (flags & VROOT_REALPATH_FL_ABS_PATH) {
++    /* If not an absolute path, prepend the current location. */
++    if (*real_path != '/') {
++      real_path = pdircat(p, pr_fs_getvwd(), path, NULL);
++
++    } else {
++      real_path = pstrdup(p, path);
++    }
++
++  } else {
++    real_path = pstrdup(p, path);
++  }
++
++  vroot_clean_path(real_path);
++
++  /* If the given path ends in a slash, remove it.  The handling of
++   * VRootAliases is sensitive to such things.
++   */
++  real_pathlen = strlen(real_path);
++  if (real_pathlen > 1 &&
++      real_path[real_pathlen-1] == '/') {
++    real_path[real_pathlen-1] = '\0';
++    real_pathlen--;
++  }
++
++  return real_path;
++}
++
+ static int vroot_lookup_path(pool *p, char *path, size_t pathlen,
+     const char *dir, int flags, char **alias_path) {
+   char buf[PR_TUNABLE_PATH_MAX + 1], *bufp = NULL;
+@@ -219,7 +278,6 @@
+ 
+   } else if (*bufp == '/') {
+     snprintf(path, pathlen, "%s/", vroot_base);
+-
+     bufp += 1;
+     goto loop;
+ 
+@@ -280,7 +338,13 @@
+     if (vroot_aliastab != NULL) {
+       char *start_ptr = NULL, *end_ptr = NULL, *src_path = NULL;
+ 
++      /* buf is used here for storing the "suffix", to be appended later when
++       * aliases are found.
++       */
++      bufp = buf;
++
+       start_ptr = path;
++
+       while (start_ptr != NULL) {
+         char *ptr;
+ 
+@@ -312,8 +376,8 @@
+           sstrncpy(path, src_path, pathlen);
+ 
+           if (end_ptr != NULL) {
+-            sstrcat(path, "/", pathlen);
+-            sstrcat(path, end_ptr + 1, pathlen);
++            /* Now tack on our suffix from the scratchpad. */
++            sstrcat(path, bufp, pathlen);
+           }
+ 
+           break;
+@@ -334,6 +398,8 @@
+           break;
+         }
+ 
++        /* Store the suffix in the buf scratchpad. */
++        sstrncpy(buf, ptr, sizeof(buf));
+         end_ptr = ptr;
+         *end_ptr = '\0';
+       }
+@@ -441,10 +507,9 @@
+ /* FS callbacks
+  */
+ 
+-static int vroot_stat(pr_fs_t *fs, const char *orig_path, struct stat *st) {
++static int vroot_stat(pr_fs_t *fs, const char *stat_path, struct stat *st) {
+   int res;
+   char vpath[PR_TUNABLE_PATH_MAX + 1], *path;
+-  size_t path_len = 0;
+   pool *tmp_pool = NULL;
+ 
+   if (session.curr_phase == LOG_CMD ||
+@@ -454,23 +519,11 @@
+     /* NOTE: once stackable FS modules are supported, have this fall through
+      * to the next module in the stack.
+      */
+-    return stat(orig_path, st);
++    return stat(stat_path, st);
+   }
+ 
+   tmp_pool = make_sub_pool(session.pool);
+-
+-  path = pstrdup(tmp_pool, orig_path);
+-  vroot_clean_path(path);
+-
+-  /* If the given path ends in a slash, remove it.  The handling of
+-   * VRootAliases is sensitive to such things.
+-   */
+-  path_len = strlen(path);
+-  if (path_len > 1 &&
+-      path[path_len-1] == '/') {
+-    path[path_len-1] = '\0';
+-    path_len--;
+-  }
++  path = vroot_realpath(tmp_pool, stat_path, 0);
+ 
+   if (vroot_lookup_path(NULL, vpath, sizeof(vpath)-1, path, 0, NULL) < 0) {
+     destroy_pool(tmp_pool);
+@@ -485,7 +538,7 @@
+ static int vroot_lstat(pr_fs_t *fs, const char *orig_path, struct stat *st) {
+   int res;
+   char vpath[PR_TUNABLE_PATH_MAX + 1], *path;
+-  size_t path_len = 0;
++  size_t pathlen = 0;
+   pool *tmp_pool = NULL;
+ 
+   if (session.curr_phase == LOG_CMD ||
+@@ -506,11 +559,11 @@
+   /* If the given path ends in a slash, remove it.  The handling of
+    * VRootAliases is sensitive to such things.
+    */
+-  path_len = strlen(path);
+-  if (path_len > 1 &&
+-      path[path_len-1] == '/') {
+-    path[path_len-1] = '\0';
+-    path_len--;
++  pathlen = strlen(path);
++  if (pathlen > 1 &&
++      path[pathlen-1] == '/') {
++    path[pathlen-1] = '\0';
++    pathlen--;
+   }
+ 
+   if (vroot_lookup_path(NULL, vpath, sizeof(vpath)-1, path, 0, NULL) < 0) {
+@@ -567,10 +620,7 @@
+   int res;
+   char vpath[PR_TUNABLE_PATH_MAX + 1];
+ 
+-  if (session.curr_phase == LOG_CMD ||
+-      session.curr_phase == LOG_CMD_ERR ||
+-      (session.sf_flags & SF_ABORT) ||
+-      *vroot_base == '\0') {
++  if (vroot_base[0] == '\0') {
+     /* NOTE: once stackable FS modules are supported, have this fall through
+      * to the next module in the stack.
+      */
+@@ -808,6 +858,28 @@
+   return res;
+ }
+ 
++static int vroot_lchown(pr_fs_t *fs, const char *path, uid_t uid, gid_t gid) {
++  int res;
++  char vpath[PR_TUNABLE_PATH_MAX + 1];
++
++  if (session.curr_phase == LOG_CMD ||
++      session.curr_phase == LOG_CMD_ERR ||
++      (session.sf_flags & SF_ABORT) ||
++      *vroot_base == '\0') {
++    /* NOTE: once stackable FS modules are supported, have this fall through
++     * to the next module in the stack.
++     */
++    res = lchown(path, uid, gid);
++    return res;
++  }
++
++  if (vroot_lookup_path(NULL, vpath, sizeof(vpath)-1, path, 0, NULL) < 0)
++    return -1;
++
++  res = lchown(vpath, uid, gid);
++  return res;
++}
++
+ static int vroot_chroot(pr_fs_t *fs, const char *path) {
+   char *chroot_path = "/", *tmp = NULL;
+   config_rec *c;
+@@ -962,7 +1034,50 @@
+   return 0;
+ }
+ 
+-static struct dirent vroot_dent;
++static int vroot_utimes(pr_fs_t *fs, const char *utimes_path,
++    struct timeval *tvs) {
++  int res;
++  char vpath[PR_TUNABLE_PATH_MAX + 1], *path;
++  pool *tmp_pool;
++
++  if (session.curr_phase == LOG_CMD ||
++      session.curr_phase == LOG_CMD_ERR ||
++      (session.sf_flags & SF_ABORT) ||
++      *vroot_base == '\0') {
++    /* NOTE: once stackable FS modules are supported, have this fall through
++     * to the next module in the stack.
++     */
++    res = utimes(utimes_path, tvs);
++    return res;
++  }
++
++  tmp_pool = make_sub_pool(session.pool);
++  path = vroot_realpath(tmp_pool, utimes_path, VROOT_REALPATH_FL_ABS_PATH);
++  
++  if (vroot_lookup_path(NULL, vpath, sizeof(vpath)-1, path, 0, NULL) < 0) {
++    destroy_pool(tmp_pool);
++    return -1;
++  }
++
++  res = utimes(vpath, tvs);
++  destroy_pool(tmp_pool);
++  return res;
++}
++
++static struct dirent *vroot_dent = NULL;
++static size_t vroot_dentsz = 0;
++
++/* On most systems, dirent.d_name is an array into which we can copy the
++ * name we want.
++ *
++ * However, on other systems (e.g. Solaris 2), dirent.d_name is an array size
++ * of 1.  This approach makes use of the fact that the d_name member is the
++ * last member of the struct, meaning that the actual size is variable.
++ *
++ * We need to Do The Right Thing(tm) in either case.
++ */
++static size_t vroot_dent_namesz = 0;
++
+ static array_header *vroot_dir_aliases = NULL;
+ static int vroot_dir_idx = -1;
+ 
+@@ -1028,7 +1143,7 @@
+   char vpath[PR_TUNABLE_PATH_MAX + 1], *path;
+   void *dirh;
+   struct stat st;
+-  size_t path_len = 0;
++  size_t pathlen = 0;
+   pool *tmp_pool = NULL;
+ 
+   if (session.curr_phase == LOG_CMD ||
+@@ -1053,11 +1168,11 @@
+   /* If the given path ends in a slash, remove it.  The handling of
+    * VRootAliases is sensitive to such things.
+    */
+-  path_len = strlen(path);
+-  if (path_len > 1 &&
+-      path[path_len-1] == '/') {
+-    path[path_len-1] = '\0';
+-    path_len--;
++  pathlen = strlen(path);
++  if (pathlen > 1 &&
++      path[pathlen-1] == '/') {
++    path[pathlen-1] = '\0';
++    pathlen--;
+   }
+ 
+   if (vroot_lookup_path(NULL, vpath, sizeof(vpath)-1, path, 0, NULL) < 0) {
+@@ -1196,11 +1311,18 @@
+         return NULL;
+       }
+ 
+-      memset(&vroot_dent, 0, sizeof(vroot_dent));
+-      sstrncpy(vroot_dent.d_name, elts[vroot_dir_idx++],
+-        sizeof(vroot_dent.d_name));
++      memset(vroot_dent, 0, vroot_dentsz);
+ 
+-      return &vroot_dent;
++      if (vroot_dent_namesz == 0) {
++        sstrncpy(vroot_dent->d_name, elts[vroot_dir_idx++],
++          sizeof(vroot_dent->d_name));
++
++      } else {
++        sstrncpy(vroot_dent->d_name, elts[vroot_dir_idx++],
++          vroot_dent_namesz);
++      }
++
++      return vroot_dent;
+     }
+   }
+ 
+@@ -1421,6 +1543,84 @@
+ /* Command handlers
+  */
+ 
++MODRET vroot_log_retr(cmd_rec *cmd) {
++  const char *key;
++  char *path;
++
++  if (vroot_engine == FALSE ||
++      session.chroot_path == NULL) {
++    return PR_DECLINED(cmd);
++  }
++
++  key = "mod_xfer.retr-path";
++
++  path = pr_table_get(cmd->notes, key, NULL);
++  if (path != NULL) {
++    char *real_path;
++
++    if (*path == '/') {
++      real_path = pdircat(cmd->pool, vroot_base, path, NULL);
++      vroot_clean_path(real_path);
++
++    } else {
++      real_path = vroot_realpath(cmd->pool, path, VROOT_REALPATH_FL_ABS_PATH);
++    }
++
++    pr_table_set(cmd->notes, key, real_path, 0);
++  }
++
++  return PR_DECLINED(cmd);
++}
++
++MODRET vroot_log_stor(cmd_rec *cmd) {
++  const char *key;
++  char *path;
++
++  if (vroot_engine == FALSE ||
++      session.chroot_path == NULL) {
++    return PR_DECLINED(cmd);
++  }
++
++  key = "mod_xfer.store-path";
++
++  path = pr_table_get(cmd->notes, key, NULL);
++  if (path != NULL) {
++    char *real_path;
++
++    if (*path == '/') {
++      real_path = pdircat(cmd->pool, vroot_base, path, NULL);
++      vroot_clean_path(real_path);
++
++    } else {
++      real_path = vroot_realpath(cmd->pool, path, VROOT_REALPATH_FL_ABS_PATH);
++    }
++
++    pr_table_set(cmd->notes, key, real_path, 0);
++  }
++
++  return PR_DECLINED(cmd);
++}
++
++MODRET vroot_pre_mkd(cmd_rec *cmd) {
++  if (vroot_engine == FALSE ||
++      session.chroot_path == NULL) {
++    return PR_DECLINED(cmd);
++  }
++
++  vroot_use_mkdtemp = pr_fsio_set_use_mkdtemp(FALSE);
++  return PR_DECLINED(cmd);
++}
++
++MODRET vroot_post_mkd(cmd_rec *cmd) {
++  if (vroot_engine == FALSE ||
++      session.chroot_path == NULL) {
++    return PR_DECLINED(cmd);
++  }
++
++  pr_fsio_set_use_mkdtemp(vroot_use_mkdtemp);
++  return PR_DECLINED(cmd);
++}
++
+ MODRET vroot_pre_pass(cmd_rec *cmd) {
+   pr_fs_t *fs = NULL;
+   unsigned char *use_vroot = NULL;
+@@ -1464,8 +1664,10 @@
+   fs->truncate = vroot_truncate;
+   fs->chmod = vroot_chmod;
+   fs->chown = vroot_chown;
++  fs->lchown = vroot_lchown;
+   fs->chdir = vroot_chdir;
+   fs->chroot = vroot_chroot;
++  fs->utimes = vroot_utimes;
+   fs->opendir = vroot_opendir;
+   fs->readdir = vroot_readdir;
+   fs->closedir = vroot_closedir;
+@@ -1540,6 +1742,7 @@
+ 
+ static int vroot_sess_init(void) {
+   config_rec *c;
++  struct dirent dent;
+ 
+   c = find_config(main_server->conf, CONF_PARAM, "VRootLog", FALSE);
+   if (c) {
+@@ -1576,6 +1779,18 @@
+     }
+   }
+ 
++  /* Allocate the memory for the static struct dirent that we use, including
++   * determining the necessary sizes.
++   */
++  vroot_dentsz = sizeof(dent);
++  if (sizeof(dent.d_name) == 1) {
++    /* Allocate extra space for the dent path name. */
++    vroot_dent_namesz = PR_TUNABLE_PATH_MAX;
++  }
++
++  vroot_dentsz += vroot_dent_namesz;
++  vroot_dent = palloc(session.pool, vroot_dentsz);
++
+   return 0;
+ }
+ 
+@@ -1595,6 +1810,34 @@
+   { PRE_CMD,		C_PASS,	G_NONE,	vroot_pre_pass, FALSE, FALSE },
+   { POST_CMD,		C_PASS,	G_NONE,	vroot_post_pass, FALSE, FALSE },
+   { POST_CMD_ERR,	C_PASS,	G_NONE,	vroot_post_pass_err, FALSE, FALSE },
++
++  { PRE_CMD,		C_MKD,	G_NONE,	vroot_pre_mkd, FALSE, FALSE },
++  { POST_CMD,		C_MKD,	G_NONE,	vroot_post_mkd, FALSE, FALSE },
++  { POST_CMD_ERR,	C_MKD,	G_NONE,	vroot_post_mkd, FALSE, FALSE },
++  { PRE_CMD,		C_XMKD,	G_NONE,	vroot_pre_mkd, FALSE, FALSE },
++  { POST_CMD,		C_XMKD,	G_NONE,	vroot_post_mkd, FALSE, FALSE },
++  { POST_CMD_ERR,	C_XMKD,	G_NONE,	vroot_post_mkd, FALSE, FALSE },
++
++  /* These command handlers are for manipulating cmd->notes, to get
++   * paths properly logged.
++   *
++   * Ideally these would be LOG_CMD/LOG_CMD_ERR phase handlers.  HOWEVER,
++   * we need to transform things before the cmd is dispatched to mod_log,
++   * and mod_log uses a C_ANY handler for logging.  And when dispatching,
++   * C_ANY handlers are run before named handlers.  This means that using
++   * LOG_CMD/LOG_CMD_ERR handlers would be run AFTER mod_log's handler,
++   * even though we appear BEFORE mod_log in the module load order.
++   *
++   * Thus to do the transformation, we actually use POST_CMD/POST_CMD_ERR
++   * phase handlers here.
++   */
++  { POST_CMD,		C_APPE,	G_NONE, vroot_log_stor, FALSE, FALSE },
++  { POST_CMD_ERR,	C_APPE,	G_NONE, vroot_log_stor, FALSE, FALSE },
++  { POST_CMD,		C_RETR,	G_NONE, vroot_log_retr, FALSE, FALSE },
++  { POST_CMD_ERR,	C_RETR,	G_NONE, vroot_log_retr, FALSE, FALSE },
++  { POST_CMD,		C_STOR,	G_NONE, vroot_log_stor, FALSE, FALSE },
++  { POST_CMD_ERR,	C_STOR,	G_NONE, vroot_log_stor, FALSE, FALSE },
++
+   { 0, NULL }
+ };
+ 
