#!/usr/local/bin/perl -I/usr/www/lib

package wagle::rebuild_share_access_tables;

use strict;
use warnings;

use Config::IniFiles;
use Service::Shares;
use nasCommon;

#-------------------------------------------------------------------------------------------------------------------------------------------------------#
my $SQL = "/usr/bin/sqlite3";
my $DBASE = "/var/oxsemi/proftpd.sqlite3";
my $VROOT_ALIASES = "/var/oxsemi/proftpd.vrootaliases";
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
my @allUsers;
my ($usersSorted, $errormesg) = Service::Shares->getSortedlUsers();
foreach my $user (@$usersSorted) {
  push @allUsers, $user->{name} 
}
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
my $sharesInc = undef;
$sharesInc = new Config::IniFiles( -file => "/var/oxsemi/shares.inc" );

my %fstype;
my %fstransport;
for (`cat /proc/mounts`) {
  chomp;
  my ($dev,$mpnt,$fstype) = split /\s+/;
  if ( $dev =~ m,^/dev/, ) {
    $fstype{$mpnt} = $fstype;
    my $scsi = $dev;
    $scsi =~ s,^/dev/,,;
    $scsi =~ s,\d+$,,;
    my $modalias = `cat /sys/block/$scsi/../../../../../modalias`;
    if ( $modalias =~ "platform:oxnassata" ) {
      $fstransport{$mpnt} = "esata";
    } else {
      $modalias = `cat /sys/block/$scsi/../../../../../../../../modalias`;
      if ( $modalias =~ "platform:oxnas-ehci" ) {
	$fstransport{$mpnt} = "usb";
      } else {
	$fstransport{$mpnt} = "unknown";
      }
    }
    #		print "dev $dev mpnt $mpnt fstype $fstype transport $fstransport{$mpnt}\n";
  }
}


#-------------------------------------------------------------------------------------------------------------------------------------------------------#
my $aliases = <<EOF;
### automatically generated by rebuild_share_access_tables.pl
EOF
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
my $query = <<EOF;
 	BEGIN TRANSACTION;
	DROP TABLE IF EXISTS ftpacl;
	CREATE TABLE ftpacl (
		mpnt TEXT,
		path TEXT NOT NULL,
		user TEXT NOT NULL,
		hidden TEXT NOT NULL,
		read_acl TEXT NOT NULL,
		write_acl TEXT NOT NULL,
		delete_acl TEXT NOT NULL,
		create_acl TEXT NOT NULL,
		modify_acl TEXT NOT NULL,
		move_acl TEXT NOT NULL,
		view_acl TEXT NOT NULL,
		navigate_acl TEXT NOT NULL,
		UNIQUE(mpnt, path, user)
		);
	CREATE INDEX ftpacl_mpnt_idx ON ftpacl (mpnt);
	CREATE INDEX ftpacl_path_idx ON ftpacl (path);
	CREATE INDEX ftpacl_user_idx ON ftpacl (user);
EOF
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
my $share = undef;
for $share ( $sharesInc->Sections ) {
  my $xfs = 0;
  my $fstransport = "unavailable";
  my $path = $sharesInc->val($share,'path');
  for my $mpnt ( keys %fstype ) {
    if ( $path eq "$mpnt/$share" ) {
      if ( $fstype{$mpnt} eq "xfs" ) {
	$fstransport = $fstransport{$mpnt};
	$xfs = 1;
	last;
      }
    }
  }
  $sharesInc->delval($share, 'preallocate');               
  $sharesInc->delval($share, 'incoherent');                        
  $sharesInc->delval($share, 'direct writes');                                                                                
  if ( $xfs ) {
    if ( $fstransport eq "esata" ) {
      $sharesInc->newval($share, 'preallocate', 'yes');
      $sharesInc->newval($share, 'incoherent', 'yes');
      $sharesInc->newval($share, 'direct writes', '2');
    } elsif ( $fstransport eq "usb" ) {
      $sharesInc->newval($share, 'preallocate', 'yes');
    } else {
      print STDERR "unknown transport\n";
    }
  }
  #	print "$share $path\n";
  my $mpnt = $path;
  $mpnt =~ s,/$share$,,;
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
  my %rwUsers;
  foreach my $u (split(/ /, $sharesInc->val($share, 'write list'))) {
    $rwUsers{$u} = ();
  }
  my %roUsers;
  foreach my $u (split(/ /, $sharesInc->val($share, 'read list'))) {
    $roUsers{$u} = ();
  }
  my %noUsers;
  foreach my $u (@allUsers) {
    next if exists $rwUsers{$u};
    next if exists $roUsers{$u};
    $noUsers{$u} = ();
  }
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
#  build query
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
  foreach my $user (@allUsers) {
    $query .= <<EOF;
	INSERT INTO ftpacl
		( mpnt, path , user    , hidden, read_acl, write_acl, delete_acl, create_acl, modify_acl, move_acl, view_acl, navigate_acl )
	 VALUES ( NULL, "/"  , "$user" , "no"  , "allow" , "deny"   , "deny"    , "deny"    , "deny"    , "deny"  ,  "allow", "allow"      )
	;
EOF
  }
  foreach my $user (keys %noUsers) {
    $query .= <<EOF;
	INSERT INTO ftpacl
	         ( mpnt   , path     , user   , hidden, read_acl, write_acl, delete_acl, create_acl, modify_acl, move_acl, view_acl, navigate_acl )
	  VALUES ( "$mpnt", "/$share", "$user", "yes" , "deny"  , "deny"   , "deny"    , "deny"    , "deny"    , "deny"  ,   "deny", "deny"       )
	;
EOF
  }
  foreach my $user (keys %roUsers) {
    $query .= <<EOF
	INSERT INTO ftpacl
	         ( mpnt   , path     , user  , hidden, read_acl, write_acl, delete_acl, create_acl, modify_acl, move_acl, view_acl, navigate_acl )
	  VALUES ( "$mpnt", "/$share", "$user", "no"  , "allow" , "deny"   , "deny"    , "deny"    , "deny"    , "deny"  ,  "allow", "allow"      )
	;
EOF
  }
  foreach my $user (keys %rwUsers) {
    $query .= <<EOF
	INSERT INTO ftpacl
		 ( mpnt   , path    , user   , hidden, read_acl, write_acl, delete_acl, create_acl, modify_acl, move_acl, view_acl, navigate_acl )
	  VALUES ( "$mpnt", "/$share", "$user", "no"  , "allow" , "allow"  , "allow"   , "allow"   , "allow"   , "allow" ,  "allow", "allow"      )
	;
EOF
  }
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
#  rebuild /var/oxsemi/proftpd.vroot-aliases
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
#	sql-ftpacl-list-disks | while IFS="|" read disk path ; do
  $aliases .= <<EOF;
	VRootAlias $mpnt/$share /$share
EOF
  if (scalar(keys %noUsers)) {
    $aliases .= <<EOF;
	<Directory />
EOF
    foreach my $user (keys %noUsers) {
      $aliases .= <<EOF;
	  HideFiles $share user $user
EOF
    }
    $aliases .= <<EOF;
	  <Limit ALL>
	    IgnoreHidden on
	  </Limit>
	</Directory>
EOF
  }
}  ### END MAIN LOOP ###
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
$query .= <<EOF;
	COMMIT
	;
EOF
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
#  write the proftpd dbacl sqlite database
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
{
  my $file = $DBASE;
  my $new_file = $file . ".NEW";
  if (open(my $F, "| $SQL $new_file")) {
    print $query;
    print $F $query;
    close($F);
    # chown 33, 33, $new_file; # running as root
    # chmod 0644, $new_file;
    rename($new_file, $file) || do {
      print STDERR "Unable to rename temp database file ($new_file) to $file: $!";
    }
  } else {
    print STDERR "Unable to create temp database file ($new_file): $!";
  }
}
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
#  write the proftpd vroot aliases config file
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
{
  my $file = $VROOT_ALIASES;
  my $new_file = $file . ".NEW";
  if (open(my $F, "> $new_file")) {
    print $aliases;
    print $F $aliases;
    close($F);
    # chown 33, 33, $new_file; # running as www-data
    # chmod 0644, $new_file;
    rename($new_file, $file) || do {
      print STDERR "Unable to rename temp config file ($new_file) to $file: $!";
    }
  } else {
    print STDERR "Unable to create temp config file ($new_file): $!";
  }
}
#------------------------------------------------------------------------------------------------------------------------------------------------------#
#  write the samba config file
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
unless ($sharesInc->RewriteConfig) {
  print STDERR "couldn't rewrite samba config file\n";
}
#------------------------------------------------------------------------------------------------------------------------------------------------------#
#  create /top/%u
#-------------------------------------------------------------------------------------------------------------------------------------------------------#
foreach my $u (@allUsers) {
  sudo("$nbin/mkdir.sh /top/$u");
}

exit 0;
